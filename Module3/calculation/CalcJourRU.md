## Обзор задач

Дано две задачи — одна **вычислительная**, на поиск выполнимого расписания для циклического планировщика, вторая — **на моделирование** с использованием **симулятора реального времени** для проверки выполнимости. Ниже описываются формулировки и требования обеих задач, условия и сведения, необходимые для выполнения, приводится подробный журнал решений.

---

### Задача первая

#### Дано

Для циклического планировщика (*cyclic scheduler*) дано **три набора задач**:

- T<sub>1</sub>(15, 1, 14); T<sub>2</sub>(20, 2, 26); T<sub>3</sub>(22, 3).  
- T<sub>1</sub>(4, 1); T<sub>2</sub>(5, 2, 7); T<sub>3</sub>(20, 5).  
- T<sub>1</sub>(5, 0.1); T<sub>2</sub>(7, 1); T<sub>3</sub>(12, 6); T<sub>4</sub>(45, 9).  

> Структура задачи: **T<sub>n</sub>(P, e, D)**, где **P** — *период (period)*, или время между двумя последовательными активациями задачи; **e** — *время выполнения (execution time)*, или длительность, необходимая для нормального завершения задачи; **D** — *крайний срок (deadline)*, или предельное время, к которому задача должна быть завершена.
> Если крайний срок **D** не задан явно — как, например, в **T<sub>3</sub>(22, 3)**, — то **D = P**, следовательно, **T<sub>3</sub>(22, 3, 22)**.

**Набор задач первый**

| **Задача** | **P** | **e** | **D** |
| ---------- | ----- | ----- | ----- |
| T₁         | 15    | 1     | 14    |
| T₂         | 20    | 2     | 26    |
| T₃         | 22    | 3     | 22    |

**Набор задач второй**

| **Задача** | **P** | **e** | **D** |
| ---------- | ----- | ----- | ----- |
| T₁         | 4     | 1     | 4     |
| T₂         | 5     | 2     | 7     |
| T₃         | 20    | 5     | 20    |

**Набор задач третий**

| **Задача** | **P** | **e** | **D** |
| ---------- | ----- | ----- | ----- |
| T₁         | 5     | 0.1   | 5     |
| T₂         | 7     | 1     | 7     |
| T₃         | 12    | 6     | 12    |
| T₄         | 45    | 9     | 45    |

#### Найти

Необходимо *для каждого из трех наборов* задач найти:

**1**. *Наибольший размер кадра*, который гарантирует своевременное выполнение всех задач (*largest feasible frame size*).

**2**. Такой наибольший размер кадра, чтобы помимо первого условия выполнялись и следующие *три требования*:

**a**. *Длительность задачи*. Каждая задача **i** должна начинаться и завершаться в пределах одного кадра **f**.  
Следовательно, **f ≥ max<sub>1 ≤ i ≤ n</sub>(e<sub>i</sub>)**, где **e<sub>i</sub>** — время выполнения (*execution time*) задачи **i**.
Никакой кадр не может быть меньше, чем самая длительная задача.
	
**b**. *Делимость гиперпериода*. Размер кадра должен равномерно (нацело) делить гиперпериод **H mod f = 0** (или **H % f == 0**).
	
> **Гиперпериодом** (*hyperperiod*) называется минимальный интервал, в который укладываются периоды всех задач. Математически гиперпериод представляет собой **наименьшее общее кратное** (*least common multiple, lcm*) всех периодов. Практически гиперпериод используется для проверки выполнимости: если расписание укладывается в крайние сроки в течение одного гиперпериода, оно будет укладываться всегда.  
> Для определения *количества кадров* **F** в гиперпериоде **H** используется простое деление: **F = H / f** (не путать с *проверкой делимости* **H mod f = 0**).
	
**c**. *Интервал между релизом и дедлайном*. Должен существовать как минимум один кадр, умещающийся между моментом запуска задачи (*release time*) и крайним сроком ее выполнения (*deadline*).  
Иначе говоря: **2f − gcd(p<sub>i</sub>, f) ≤ D<sub>i</sub>**, где **f** — размер кадра; **p<sub>i</sub>** — период задачи **i**; **D<sub>i</sub>** — крайний срок выполнения задачи **i**; **gcd(p<sub>i</sub>, f)** — наибольший общий делитель (*greatest common divisor, gcd*) для значений периода и кадра.

#### Условия

Решение выполняется с использованием листа бумаги и ручки.

#### Решение

**Логика поиска**
1. Найти гиперпериод **H = lcm(P<sub>1</sub>, P<sub>2</sub>, ... P<sub>n</sub>)**.  
2. Выбрать среди кандидатов кадры **f** (делители **H**), которые:  
- **≥ max<sub>1 ≤ i ≤ n</sub>(e<sub>i</sub>)** — требование 1,  
- **H mod f = 0** — требование 2.  
3. Проверить выбранные **f** на условие **2f − gcd(p<sub>i</sub>, f) ≤ D<sub>i</sub>** для всех задач — требование 3.  
4. Из прошедших проверку **f** выбрать максимальное.

**Шаг 1**
Найдем сперва НОК периодов **P** для каждого набора.

- Для первого набора: НОК(15, 20, 22) = **660**.  
- Для второго набора: НОК(4, 5, 20) = **20**.  
- Для третьего набора: НОК(5, 7, 12, 45) = **1260**.

**Шаг 2.1**
Найдем для каждого набора требование к нижней границе **f**, а именно задачу с самым большим временем выполнения **e**.

- Для первого набора: задача T<sub>3</sub>(22, 3), тогда **f ≥ 3**.  
- Для второго набора: задача T<sub>3</sub>(20, 5), тогда **f ≥ 5**.  
- Для третьего набора: задача T<sub>4</sub>(45, 9), тогда **f ≥ 9**.

**Шаг 2.2**
Согласно второму требованию, искомое значение кадра должно делить гиперпериод **H** нацело.

**Пример «ручного» поиска делителей для числа 660**  
Разложим 660 на простые множители:

660 / 2 = 330,  
330 / 2 = 165, больше не делится на 2, запишем 2<sup>2</sup>.  
165 / 3 = 55, больше не делится на 3, запишем 3.  
55 / 5 = 11, запишем 5.  
Осталось 11 — простое число, запишем 11.  
Итого: **660 = 2<sup>2</sup> * 3 * 5 * 11**.  

Каждый делитель числа 660 — это число, которое можно «собрать», взяв **степени** из разложения:

- от 0 до 2 для 2,  
- от 0 до 1 для 3,  
- от 0 до 1 для 5,  
- от 0 до 1 для 11.

Соберем возможные комбинации этих степеней:  
**d = 2<sup>a</sup> * 3<sup>b</sup> * 5<sup>c</sup> * 11<sup>d</sup>, a ∈ {0, 1, 2},  b, c, d ∈ {0, 1}**.

Количество (положительных) делителей: 3 * 2 * 2 * 2 = **24**. Чтобы найти **все делители**, нужно перебрать **все комбинации** указанных выше степеней и для каждой вычислить значение по формуле.

**Пример автоматизированного поиска делителей для положительного целого числа**
```python
def get_divisors(n):
    if not isinstance(n, int) or n <= 0:
        raise ValueError("Введите положительное целое число")

    divisors = []
    for i in range(1, int(n**0.5) + 1):
        if n % i == 0:
            divisors.append(i)
            if i != n // i:
                divisors.append(n // i)
    return sorted(divisors)

# Пример использования:
number = int(input("Введите положительное целое число: "))
print("Делители:", get_divisors(number))
```

Запуск, ввод, вывод:
![Freehand Drawing.svg](assets/01.divisorsRU.png)

Итак, **все** делители гиперпериода для каждого набора задач:

- Для первого набора (660): 1, 2, 3, 4, 5, 6, 10, 11, 12, 15, 20, 22, 30, 33, 44, 55, 60, 66, 110, 132, 165, 220, 330, 660.  
- Для второго набора (20): 1, 2, 4, 5, 10, 20.  
- Для третьего набора (1260): 1, 2, 3, 4, 5, 6, 7, 9, 10, 12, 14, 15, 18, 20, 21, 28, 30, 35, 36, 42, 45, 60, 63, 70, 84, 90, 105, 126, 140, 180, 210, 252, 315, 420, 630, 1260.

Применим требование к нижней границе **f** и получим:

- Для первого набора, *f ≥ 3*: 3, 4, 5, 6, 10, 11, 12, 15, 20, 22, 30, 33, 44, 55, 60, 66, 110, 132, 165, 220, 330, 660.  
- Для второго набора, *f ≥ 5*: 5, 10, 20.  
- Для третьего набора, *f ≥ 9*: 9, 10, 12, 14, 15, 18, 20, 21, 28, 30, 35, 36, 42, 45, 60, 63, 70, 84, 90, 105, 126, 140, 180, 210, 252, 315, 420, 630, 1260.

**Шаг 3**

**Шаг 4**

#### Результат

---

### Задача вторая

